#!/usr/bin/env python3
"""
VIB - Remote Development Bridge Tool

A CLI tool that enables commands run on a remote SSH machine to trigger
actions on the local/client machine via SSH Unix socket forwarding.
"""

import argparse
import json
import os
import signal
import socket
import subprocess
import sys
import threading
import time
from pathlib import Path


# Paths
VIB_DIR = Path.home() / ".vib"
LOCAL_SOCKET = VIB_DIR / "vib.sock"
REMOTE_SOCKET = Path(f"/tmp/vib-{os.environ.get('USER', 'unknown')}.sock")
CONFIG_FILE = VIB_DIR / "config"


def parse_ssh_config():
    """Parse ~/.ssh/config and return a mapping of HostName -> Host alias."""
    ssh_config = Path.home() / ".ssh" / "config"
    if not ssh_config.exists():
        return {}

    mapping = {}
    current_host = None

    try:
        for line in ssh_config.read_text().splitlines():
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            # Match "Host alias" (but not wildcard patterns)
            if line.lower().startswith("host ") and not line.lower().startswith("hostname"):
                alias = line.split(None, 1)[1].strip()
                if "*" not in alias and "?" not in alias:
                    current_host = alias
                else:
                    current_host = None
            # Match "HostName actual.hostname.com"
            elif line.lower().startswith("hostname") and current_host:
                hostname = line.split(None, 1)[1].strip() if len(line.split(None, 1)) > 1 else None
                if hostname:
                    mapping[hostname] = current_host
        return mapping
    except Exception:
        return {}


def get_config_host():
    """Get the SSH host alias from ~/.vib/config on the remote.

    Format:
        host = anton
    """
    if not CONFIG_FILE.exists():
        return None

    try:
        for line in CONFIG_FILE.read_text().splitlines():
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            if line.lower().startswith("host"):
                # "host = anton" or "host=anton"
                if "=" in line:
                    return line.split("=", 1)[1].strip()
        return None
    except Exception:
        return None


def resolve_hostname_to_ips(hostname: str) -> list:
    """Resolve a hostname to its IP addresses."""
    try:
        results = socket.getaddrinfo(hostname, None, socket.AF_UNSPEC, socket.SOCK_STREAM)
        return list(set(r[4][0] for r in results))
    except socket.gaierror:
        return []


def resolve_host_alias(host: str) -> str:
    """Resolve an IP/hostname to an SSH config Host alias.

    Parses ~/.ssh/config, resolves each HostName to IPs,
    and matches against the incoming host.
    """
    # Get mapping of HostName -> Host alias from SSH config
    ssh_mapping = parse_ssh_config()

    # Direct match on hostname
    if host in ssh_mapping:
        return ssh_mapping[host]

    # Resolve each HostName to IPs and check for match
    for hostname, alias in ssh_mapping.items():
        ips = resolve_hostname_to_ips(hostname)
        if host in ips:
            return alias

    return host


def get_git_branch():
    """Get the current git branch name."""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--abbrev-ref", "HEAD"],
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        return None


def get_git_remote_url():
    """Get the GitHub URL from git remote."""
    try:
        result = subprocess.run(
            ["git", "remote", "get-url", "origin"],
            capture_output=True,
            text=True,
            check=True,
        )
        url = result.stdout.strip()
        # Convert SSH URL to HTTPS if needed
        if url.startswith("git@github.com:"):
            url = url.replace("git@github.com:", "https://github.com/")
        if url.endswith(".git"):
            url = url[:-4]
        return url
    except subprocess.CalledProcessError:
        return None


def get_remote_host():
    """Get the remote host identifier for SSH connection."""
    # Try SSH_CONNECTION first (format: "client_ip client_port server_ip server_port")
    ssh_conn = os.environ.get("SSH_CONNECTION")
    if ssh_conn:
        parts = ssh_conn.split()
        if len(parts) >= 3:
            # Return the server IP that the client connected to
            return parts[2]

    # Fall back to hostname
    try:
        result = subprocess.run(
            ["hostname", "-f"],
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        return socket.gethostname()


class TunnelManager:
    """Manages SSH tunnel with automatic reconnection."""

    def __init__(self, host: str, local_socket: Path, stop_event: threading.Event):
        self.host = host
        self.local_socket = local_socket
        self.remote_socket = f"/tmp/vib-{os.environ.get('USER', 'unknown')}.sock"
        self.stop_event = stop_event
        self.process = None
        self.backoff = 1  # Start with 1 second
        self.max_backoff = 60  # Max 60 seconds

    def _build_ssh_command(self) -> list:
        """Build the SSH command for reverse forwarding."""
        return [
            "ssh",
            "-N",  # No remote command
            "-o", "ServerAliveInterval=30",
            "-o", "ServerAliveCountMax=3",
            "-o", "ExitOnForwardFailure=yes",
            "-o", "BatchMode=yes",  # Don't prompt for password
            "-R", f"{self.remote_socket}:{self.local_socket}",
            self.host,
        ]

    def _start_ssh(self) -> bool:
        """Start the SSH subprocess. Returns True if started successfully."""
        cmd = self._build_ssh_command()
        try:
            self.process = subprocess.Popen(
                cmd,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.PIPE,
            )
            # Give SSH a moment to establish or fail
            time.sleep(1)

            if self.process.poll() is not None:
                # Process already exited
                stderr = self.process.stderr.read().decode().strip() if self.process.stderr else ""
                print(f"SSH tunnel failed to start: {stderr}")
                return False

            print(f"SSH tunnel established to {self.host}")
            self.backoff = 1  # Reset backoff on success
            return True
        except Exception as e:
            print(f"Failed to start SSH: {e}")
            return False

    def _wait_for_exit(self) -> int:
        """Wait for SSH process to exit. Returns exit code."""
        if self.process is None:
            return -1

        while not self.stop_event.is_set():
            try:
                exit_code = self.process.wait(timeout=1)
                stderr = self.process.stderr.read().decode().strip() if self.process.stderr else ""
                if stderr:
                    print(f"SSH tunnel closed: {stderr}")
                else:
                    print(f"SSH tunnel closed (exit code {exit_code})")
                return exit_code
            except subprocess.TimeoutExpired:
                continue

        return 0

    def run(self):
        """Main loop: start SSH, monitor, reconnect on failure."""
        print(f"Starting tunnel manager for {self.host}...")

        while not self.stop_event.is_set():
            if self._start_ssh():
                self._wait_for_exit()

            if self.stop_event.is_set():
                break

            print(f"Reconnecting in {self.backoff}s...")
            # Wait with stop_event check
            for _ in range(self.backoff):
                if self.stop_event.is_set():
                    return
                time.sleep(1)

            # Exponential backoff
            self.backoff = min(self.backoff * 2, self.max_backoff)

    def stop(self):
        """Stop the SSH tunnel."""
        if self.process and self.process.poll() is None:
            print("Terminating SSH tunnel...")
            self.process.terminate()
            try:
                self.process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                self.process.kill()


def send_to_daemon(message: dict, socket_path: Path = REMOTE_SOCKET) -> dict:
    """Send a message to the daemon and get response."""
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    try:
        sock.connect(str(socket_path))
        sock.sendall(json.dumps(message).encode() + b"\n")

        # Receive response
        response = b""
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            response += chunk
            if b"\n" in response:
                break

        if response:
            return json.loads(response.decode().strip())
        return {"status": "ok"}
    except FileNotFoundError:
        return {"status": "error", "message": f"Socket not found: {socket_path}. Is the daemon running?"}
    except ConnectionRefusedError:
        return {"status": "error", "message": "Connection refused. Is the daemon running?"}
    except Exception as e:
        return {"status": "error", "message": str(e)}
    finally:
        sock.close()


def handle_daemon_request(data: dict) -> dict:
    """Handle an incoming request on the daemon side."""
    action = data.get("action")

    if action == "openpr":
        return handle_openpr_daemon(data)
    elif action == "curs":
        return handle_curs_daemon(data)
    else:
        return {"status": "error", "message": f"Unknown action: {action}"}


def handle_openpr_daemon(data: dict) -> dict:
    """Handle openpr request - open Chrome with PR URL."""
    branch = data.get("branch")
    repo_url = data.get("repo_url")

    if not branch or not repo_url:
        return {"status": "error", "message": "Missing branch or repo_url"}

    # Extract owner/repo from URL
    # URL format: https://github.com/owner/repo
    parts = repo_url.rstrip("/").split("/")
    if len(parts) < 2:
        return {"status": "error", "message": f"Invalid repo URL: {repo_url}"}

    owner = parts[-2]
    repo = parts[-1]

    pr_url = f"https://github.com/{owner}/{repo}/compare/{branch}?expand=1"

    try:
        # Try different browser commands (macOS uses 'open', Linux uses xdg-open or specific browsers)
        for browser in ["open", "xdg-open", "google-chrome", "google-chrome-stable", "chromium", "chromium-browser"]:
            try:
                subprocess.Popen(
                    [browser, pr_url],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                )
                print(f"Opened PR URL: {pr_url}")
                return {"status": "ok", "url": pr_url}
            except FileNotFoundError:
                continue

        return {"status": "error", "message": "No browser found"}
    except Exception as e:
        return {"status": "error", "message": str(e)}


def handle_curs_daemon(data: dict) -> dict:
    """Handle curs request - open Cursor with SSH remote."""
    host = data.get("host")
    user = data.get("user")
    path = data.get("path")
    diff = data.get("diff", False)

    if not host or not path:
        return {"status": "error", "message": "Missing host or path"}

    # Resolve host to SSH config alias (e.g., "192.168.0.35" -> "anton")
    host_alias = resolve_host_alias(host)
    if host_alias != host:
        print(f"Resolved {host} -> {host_alias}")

    # Build remote identifier using the alias (don't include user if using alias)
    if host_alias != host:
        # Using SSH config alias - it already has user configured
        remote_id = host_alias
    elif user:
        remote_id = f"{user}@{host}"
    else:
        remote_id = host

    # Find cursor binary - check PATH first, then common macOS locations
    cursor_paths = [
        "cursor",  # Check PATH first
        "/Applications/Cursor.app/Contents/Resources/app/bin/cursor",
        "/usr/local/bin/cursor",
        os.path.expanduser("~/Applications/Cursor.app/Contents/Resources/app/bin/cursor"),
    ]

    cursor_bin = None
    for cp in cursor_paths:
        if cp == "cursor":
            # Check if cursor is in PATH
            import shutil
            if shutil.which("cursor"):
                cursor_bin = "cursor"
                break
        elif os.path.exists(cp):
            cursor_bin = cp
            break

    if not cursor_bin:
        return {"status": "error", "message": "Cursor not found. Install Cursor or check installation path."}

    try:
        # Open Cursor with SSH remote
        subprocess.Popen(
            [cursor_bin, "--remote", f"ssh-remote+{remote_id}", path],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        print(f"Opening Cursor: ssh-remote+{remote_id} {path}")

        if diff:
            # Give Cursor time to start, then open Source Control view
            import time
            time.sleep(2)
            subprocess.Popen(
                [cursor_bin, "--goto", "scm"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            print("Opening Source Control view")

        return {"status": "ok", "remote": remote_id, "path": path, "diff": diff}
    except FileNotFoundError:
        return {"status": "error", "message": "Cursor not found"}
    except Exception as e:
        return {"status": "error", "message": str(e)}


def run_socket_listener(sock, stop_event):
    """Run the socket listener in a thread."""
    sock.settimeout(1.0)  # Allow periodic checking of stop_event
    while not stop_event.is_set():
        try:
            conn, _ = sock.accept()
            try:
                data = b""
                while True:
                    chunk = conn.recv(4096)
                    if not chunk:
                        break
                    data += chunk
                    if b"\n" in data:
                        break

                if data:
                    try:
                        message = json.loads(data.decode().strip())
                        print(f"Received: {message}")
                        response = handle_daemon_request(message)
                    except json.JSONDecodeError as e:
                        response = {"status": "error", "message": f"Invalid JSON: {e}"}

                    conn.sendall(json.dumps(response).encode() + b"\n")
            finally:
                conn.close()
        except socket.timeout:
            continue
        except Exception as e:
            if not stop_event.is_set():
                print(f"Socket error: {e}")


def run_daemon(tunnel_host: str = None):
    """Run the daemon that listens for commands.

    Args:
        tunnel_host: If provided, establish SSH tunnel to this host with reverse forwarding
    """
    # Ensure socket directory exists
    LOCAL_SOCKET.parent.mkdir(parents=True, exist_ok=True)

    # Remove existing socket
    if LOCAL_SOCKET.exists():
        LOCAL_SOCKET.unlink()

    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.bind(str(LOCAL_SOCKET))
    sock.listen(5)

    # Set socket permissions
    os.chmod(LOCAL_SOCKET, 0o600)

    print(f"VIB daemon listening on {LOCAL_SOCKET}")

    stop_event = threading.Event()
    tunnel_manager = None

    # Start tunnel if host specified
    if tunnel_host:
        print(f"Establishing SSH tunnel to {tunnel_host}...")
        tunnel_manager = TunnelManager(tunnel_host, LOCAL_SOCKET, stop_event)
        tunnel_thread = threading.Thread(
            target=tunnel_manager.run,
            daemon=True,
        )
        tunnel_thread.start()
    else:
        print(f"Add to ~/.ssh/config: RemoteForward /tmp/vib-$USER.sock {LOCAL_SOCKET}")

    print("Press Ctrl+C to stop...")

    # Start socket listener in a thread
    listener_thread = threading.Thread(
        target=run_socket_listener,
        args=(sock, stop_event),
        daemon=True,
    )
    listener_thread.start()

    # Set up signal handlers for graceful shutdown
    def handle_signal(signum, frame):
        print(f"\nReceived signal {signum}, shutting down...")
        stop_event.set()

    signal.signal(signal.SIGTERM, handle_signal)
    signal.signal(signal.SIGINT, handle_signal)

    try:
        while not stop_event.is_set():
            signal.pause()
    except KeyboardInterrupt:
        pass
    finally:
        print("Shutting down...")
        stop_event.set()
        if tunnel_manager:
            tunnel_manager.stop()
        sock.close()
        if LOCAL_SOCKET.exists():
            LOCAL_SOCKET.unlink()


def cmd_daemon(args):
    """Handle 'vib daemon' command."""
    tunnel_host = None

    if args.tunnel is not None:
        if args.tunnel:
            # Explicit host provided: --tunnel gpu
            tunnel_host = args.tunnel
        else:
            # Just --tunnel with no argument, read from config
            tunnel_host = get_config_host()
            if not tunnel_host:
                print("Error: No host specified and no host in ~/.vib/config", file=sys.stderr)
                print("Usage: vib daemon --tunnel HOST  or  set 'host = yourhost' in ~/.vib/config", file=sys.stderr)
                sys.exit(1)

    run_daemon(tunnel_host=tunnel_host)


def cmd_install(args):
    """Handle 'vib install' command - set up systemd user service."""
    import shutil

    # Check for systemd
    if not shutil.which("systemctl"):
        print("Error: systemctl not found. Is systemd installed?", file=sys.stderr)
        sys.exit(1)

    # Get the host for the tunnel
    host = args.host if args.host else get_config_host()
    if not host:
        print("Error: No host specified and no host in ~/.vib/config", file=sys.stderr)
        print("Usage: vib install HOST  or  set 'host = yourhost' in ~/.vib/config first", file=sys.stderr)
        sys.exit(1)

    # Get path to this script
    vib_path = os.path.abspath(__file__)

    # Create systemd user directory
    systemd_dir = Path.home() / ".config" / "systemd" / "user"
    systemd_dir.mkdir(parents=True, exist_ok=True)

    service_file = systemd_dir / "vib.service"

    # Create service file content
    service_content = f"""[Unit]
Description=VIB Remote Development Bridge
After=network.target

[Service]
Type=simple
ExecStart={vib_path} daemon --tunnel {host}
Restart=on-failure
RestartSec=5

[Install]
WantedBy=default.target
"""

    # Write service file
    service_file.write_text(service_content)
    print(f"Created {service_file}")

    # Run systemctl commands
    commands = [
        (["systemctl", "--user", "daemon-reload"], "Reloading systemd..."),
        (["systemctl", "--user", "enable", "vib"], "Enabling vib service..."),
        (["systemctl", "--user", "restart", "vib"], "Starting vib service..."),
    ]

    for cmd, msg in commands:
        print(msg)
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode != 0:
            print(f"Error: {result.stderr.strip()}", file=sys.stderr)
            sys.exit(1)

    # Print status
    print("\nVIB service installed and started!")
    print(f"Tunnel target: {host}")
    print("\nUseful commands:")
    print("  systemctl --user status vib    # Check status")
    print("  journalctl --user -u vib -f    # View logs")
    print("  systemctl --user restart vib   # Restart service")
    print("  systemctl --user stop vib      # Stop service")

    # Show current status
    print("\nCurrent status:")
    subprocess.run(["systemctl", "--user", "status", "vib", "--no-pager"])


def cmd_openpr(args):
    """Handle 'vib openpr' command."""
    branch = get_git_branch()
    if not branch:
        print("Error: Not in a git repository or cannot determine branch", file=sys.stderr)
        sys.exit(1)

    repo_url = get_git_remote_url()
    if not repo_url:
        print("Error: Cannot determine git remote URL", file=sys.stderr)
        sys.exit(1)

    if "github.com" not in repo_url:
        print(f"Error: Only GitHub repositories are supported. Got: {repo_url}", file=sys.stderr)
        sys.exit(1)

    message = {
        "action": "openpr",
        "branch": branch,
        "repo_url": repo_url,
    }

    print(f"Opening PR for branch '{branch}' in {repo_url}")
    response = send_to_daemon(message)

    if response.get("status") == "error":
        print(f"Error: {response.get('message')}", file=sys.stderr)
        sys.exit(1)
    else:
        print(f"PR URL opened: {response.get('url', 'unknown')}")


def cmd_curs(args):
    """Handle 'vib curs' command."""
    # Get path (default to cwd)
    path = args.path if args.path else os.getcwd()
    path = os.path.abspath(path)

    # Get remote host info (priority: ~/.vib/config > VIB_HOST env > auto-detect)
    host = get_config_host() or os.environ.get("VIB_HOST") or get_remote_host()
    user = os.environ.get("USER")

    message = {
        "action": "curs",
        "host": host,
        "user": user,
        "path": path,
        "diff": args.diff,
    }

    print(f"Opening Cursor for {user}@{host}:{path}" + (" (diff mode)" if args.diff else ""))
    response = send_to_daemon(message)

    if response.get("status") == "error":
        print(f"Error: {response.get('message')}", file=sys.stderr)
        sys.exit(1)
    else:
        print("Cursor opened successfully")


def main():
    parser = argparse.ArgumentParser(
        description="VIB - Remote Development Bridge Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  Local machine setup (one-time):
    vib install anton       Install as systemd service with tunnel to 'anton'
    vib install             Use host from ~/.vib/config

  Local machine (manual):
    vib daemon --tunnel anton   Start daemon with SSH tunnel to 'anton'
    vib daemon --tunnel         Use host from ~/.vib/config
    vib daemon                  Start daemon only (manual SSH forwarding)

  Remote machine (via SSH):
    vib openpr              Open GitHub PR creation page for current branch
    vib curs                Open Cursor connected to current directory
    vib curs /path/to/dir   Open Cursor connected to specific directory
    vib curs --diff         Open Cursor with Source Control view focused

  Config file (~/.vib/config):
    host = anton            Default SSH host for tunnel

  Service management:
    systemctl --user status vib     Check service status
    journalctl --user -u vib -f     View logs
    systemctl --user restart vib    Restart service
        """,
    )

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # daemon command
    daemon_parser = subparsers.add_parser("daemon", help="Start the local daemon")
    daemon_parser.add_argument(
        "--tunnel", nargs="?", const="", default=None, metavar="HOST",
        help="Establish SSH tunnel to HOST (uses ~/.vib/config if HOST not specified)"
    )
    daemon_parser.set_defaults(func=cmd_daemon)

    # install command
    install_parser = subparsers.add_parser("install", help="Install as systemd user service")
    install_parser.add_argument(
        "host", nargs="?", default=None,
        help="SSH host to tunnel to (uses ~/.vib/config if not specified)"
    )
    install_parser.set_defaults(func=cmd_install)

    # openpr command
    openpr_parser = subparsers.add_parser("openpr", help="Open GitHub PR creation page")
    openpr_parser.set_defaults(func=cmd_openpr)

    # curs command
    curs_parser = subparsers.add_parser("curs", help="Open Cursor with SSH remote")
    curs_parser.add_argument("path", nargs="?", help="Path to open (default: current directory)")
    curs_parser.add_argument("--diff", action="store_true", help="Open Source Control view for diffs")
    curs_parser.set_defaults(func=cmd_curs)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    args.func(args)


if __name__ == "__main__":
    main()
