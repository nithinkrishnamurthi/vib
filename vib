#!/usr/bin/env python3
"""
VIB - Remote Development Bridge Tool

A CLI tool that enables commands run on a remote SSH machine to trigger
actions on the local/client machine via SSH Unix socket forwarding.
"""

import argparse
import json
import os
import signal
import socket
import subprocess
import sys
import threading
from pathlib import Path


# Paths
VIB_DIR = Path.home() / ".vib"
CONFIG_FILE = VIB_DIR / "config.json"
LOCAL_SOCKET = VIB_DIR / "vib.sock"
REMOTE_SOCKET = Path(f"/tmp/vib-{os.environ.get('USER', 'unknown')}.sock")


def load_config() -> dict:
    """Load config from ~/.vib/config.json"""
    if CONFIG_FILE.exists():
        try:
            return json.loads(CONFIG_FILE.read_text())
        except (json.JSONDecodeError, IOError):
            return {}
    return {}


def save_config(config: dict):
    """Save config to ~/.vib/config.json"""
    VIB_DIR.mkdir(parents=True, exist_ok=True)
    CONFIG_FILE.write_text(json.dumps(config, indent=2) + "\n")


def get_git_branch():
    """Get the current git branch name."""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--abbrev-ref", "HEAD"],
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        return None


def get_git_remote_url():
    """Get the GitHub URL from git remote."""
    try:
        result = subprocess.run(
            ["git", "remote", "get-url", "origin"],
            capture_output=True,
            text=True,
            check=True,
        )
        url = result.stdout.strip()
        # Convert SSH URL to HTTPS if needed
        if url.startswith("git@github.com:"):
            url = url.replace("git@github.com:", "https://github.com/")
        if url.endswith(".git"):
            url = url[:-4]
        return url
    except subprocess.CalledProcessError:
        return None


def get_remote_host():
    """Get the remote host identifier for SSH connection."""
    # Try SSH_CONNECTION first (format: "client_ip client_port server_ip server_port")
    ssh_conn = os.environ.get("SSH_CONNECTION")
    if ssh_conn:
        parts = ssh_conn.split()
        if len(parts) >= 3:
            # Return the server IP that the client connected to
            return parts[2]

    # Fall back to hostname
    try:
        result = subprocess.run(
            ["hostname", "-f"],
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        return socket.gethostname()


def send_to_daemon(message: dict, socket_path: Path = REMOTE_SOCKET) -> dict:
    """Send a message to the daemon and get response."""
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    try:
        sock.connect(str(socket_path))
        sock.sendall(json.dumps(message).encode() + b"\n")

        # Receive response
        response = b""
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            response += chunk
            if b"\n" in response:
                break

        if response:
            return json.loads(response.decode().strip())
        return {"status": "ok"}
    except FileNotFoundError:
        return {"status": "error", "message": f"Socket not found: {socket_path}. Is the daemon running?"}
    except ConnectionRefusedError:
        return {"status": "error", "message": "Connection refused. Is the daemon running?"}
    except Exception as e:
        return {"status": "error", "message": str(e)}
    finally:
        sock.close()


def handle_daemon_request(data: dict) -> dict:
    """Handle an incoming request on the daemon side."""
    action = data.get("action")

    if action == "openpr":
        return handle_openpr_daemon(data)
    elif action == "curs":
        return handle_curs_daemon(data)
    else:
        return {"status": "error", "message": f"Unknown action: {action}"}


def handle_openpr_daemon(data: dict) -> dict:
    """Handle openpr request - open Chrome with PR URL."""
    branch = data.get("branch")
    repo_url = data.get("repo_url")

    if not branch or not repo_url:
        return {"status": "error", "message": "Missing branch or repo_url"}

    # Extract owner/repo from URL
    # URL format: https://github.com/owner/repo
    parts = repo_url.rstrip("/").split("/")
    if len(parts) < 2:
        return {"status": "error", "message": f"Invalid repo URL: {repo_url}"}

    owner = parts[-2]
    repo = parts[-1]

    pr_url = f"https://github.com/{owner}/{repo}/compare/{branch}?expand=1"

    try:
        # Try different browser commands
        for browser in ["google-chrome", "google-chrome-stable", "chromium", "chromium-browser", "xdg-open"]:
            try:
                subprocess.Popen(
                    [browser, pr_url],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                )
                print(f"Opened PR URL: {pr_url}")
                return {"status": "ok", "url": pr_url}
            except FileNotFoundError:
                continue

        return {"status": "error", "message": "No browser found"}
    except Exception as e:
        return {"status": "error", "message": str(e)}


def handle_curs_daemon(data: dict) -> dict:
    """Handle curs request - open Cursor with SSH remote."""
    host = data.get("host")
    user = data.get("user")
    path = data.get("path")
    diff = data.get("diff", False)

    if not host or not path:
        return {"status": "error", "message": "Missing host or path"}

    # Build remote identifier
    if user:
        remote_id = f"{user}@{host}"
    else:
        remote_id = host

    try:
        # Open Cursor with SSH remote
        subprocess.Popen(
            ["cursor", "--remote", f"ssh-remote+{remote_id}", path],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        print(f"Opening Cursor: ssh-remote+{remote_id} {path}")

        if diff:
            # Give Cursor time to start, then open Source Control view
            import time
            time.sleep(2)
            subprocess.Popen(
                ["cursor", "--goto", "scm"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            print("Opening Source Control view")

        return {"status": "ok", "remote": remote_id, "path": path, "diff": diff}
    except FileNotFoundError:
        return {"status": "error", "message": "Cursor not found in PATH"}
    except Exception as e:
        return {"status": "error", "message": str(e)}


def run_socket_listener(sock, stop_event):
    """Run the socket listener in a thread."""
    sock.settimeout(1.0)  # Allow periodic checking of stop_event
    while not stop_event.is_set():
        try:
            conn, _ = sock.accept()
            try:
                data = b""
                while True:
                    chunk = conn.recv(4096)
                    if not chunk:
                        break
                    data += chunk
                    if b"\n" in data:
                        break

                if data:
                    try:
                        message = json.loads(data.decode().strip())
                        print(f"Received: {message}")
                        response = handle_daemon_request(message)
                    except json.JSONDecodeError as e:
                        response = {"status": "error", "message": f"Invalid JSON: {e}"}

                    conn.sendall(json.dumps(response).encode() + b"\n")
            finally:
                conn.close()
        except socket.timeout:
            continue
        except Exception as e:
            if not stop_event.is_set():
                print(f"Socket error: {e}")


def run_daemon(host: str = None):
    """Run the daemon that listens for commands and optionally SSH to host."""
    # Ensure socket directory exists
    LOCAL_SOCKET.parent.mkdir(parents=True, exist_ok=True)

    # Remove existing socket
    if LOCAL_SOCKET.exists():
        LOCAL_SOCKET.unlink()

    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.bind(str(LOCAL_SOCKET))
    sock.listen(5)

    # Set socket permissions
    os.chmod(LOCAL_SOCKET, 0o600)

    print(f"VIB daemon listening on {LOCAL_SOCKET}")

    stop_event = threading.Event()
    ssh_proc = None

    # Start socket listener in a thread
    listener_thread = threading.Thread(
        target=run_socket_listener,
        args=(sock, stop_event),
        daemon=True,
    )
    listener_thread.start()

    try:
        if host:
            # Get remote user for socket path
            remote_user = host.split("@")[0] if "@" in host else os.environ.get("USER", "unknown")
            remote_socket = f"/tmp/vib-{remote_user}.sock"

            # Build SSH command with socket forwarding
            ssh_cmd = [
                "ssh",
                "-R", f"{remote_socket}:{LOCAL_SOCKET}",
                "-o", "StreamLocalBindUnlink=yes",  # Remove existing socket on remote
                "-o", "ExitOnForwardFailure=yes",
                host,
            ]

            print(f"Connecting to {host} with socket forwarding...")
            print(f"Remote socket: {remote_socket}")

            # Run SSH (this blocks until SSH exits)
            ssh_proc = subprocess.Popen(ssh_cmd)
            ssh_proc.wait()
            print("SSH session ended")
        else:
            # No host configured, just run the daemon
            print("No host configured. Run 'vib config <user@host>' to set remote host.")
            print("Or manually SSH with: ssh -R /tmp/vib-$USER.sock:~/.vib/vib.sock <host>")
            print("Press Ctrl+C to stop...")
            while True:
                signal.pause()

    except KeyboardInterrupt:
        print("\nShutting down...")
    finally:
        stop_event.set()
        if ssh_proc and ssh_proc.poll() is None:
            ssh_proc.terminate()
        sock.close()
        if LOCAL_SOCKET.exists():
            LOCAL_SOCKET.unlink()


def cmd_daemon(args):
    """Handle 'vib daemon' command."""
    config = load_config()
    host = args.host or config.get("host")
    run_daemon(host)


def cmd_config(args):
    """Handle 'vib config' command."""
    config = load_config()

    if args.host:
        config["host"] = args.host
        save_config(config)
        print(f"Remote host set to: {args.host}")
    else:
        if config.get("host"):
            print(f"Remote host: {config['host']}")
        else:
            print("No remote host configured.")
            print("Usage: vib config <user@host>")
        print(f"\nConfig file: {CONFIG_FILE}")


def cmd_openpr(args):
    """Handle 'vib openpr' command."""
    branch = get_git_branch()
    if not branch:
        print("Error: Not in a git repository or cannot determine branch", file=sys.stderr)
        sys.exit(1)

    repo_url = get_git_remote_url()
    if not repo_url:
        print("Error: Cannot determine git remote URL", file=sys.stderr)
        sys.exit(1)

    if "github.com" not in repo_url:
        print(f"Error: Only GitHub repositories are supported. Got: {repo_url}", file=sys.stderr)
        sys.exit(1)

    message = {
        "action": "openpr",
        "branch": branch,
        "repo_url": repo_url,
    }

    print(f"Opening PR for branch '{branch}' in {repo_url}")
    response = send_to_daemon(message)

    if response.get("status") == "error":
        print(f"Error: {response.get('message')}", file=sys.stderr)
        sys.exit(1)
    else:
        print(f"PR URL opened: {response.get('url', 'unknown')}")


def cmd_curs(args):
    """Handle 'vib curs' command."""
    # Get path (default to cwd)
    path = args.path if args.path else os.getcwd()
    path = os.path.abspath(path)

    # Get remote host info
    host = get_remote_host()
    user = os.environ.get("USER")

    message = {
        "action": "curs",
        "host": host,
        "user": user,
        "path": path,
        "diff": args.diff,
    }

    print(f"Opening Cursor for {user}@{host}:{path}" + (" (diff mode)" if args.diff else ""))
    response = send_to_daemon(message)

    if response.get("status") == "error":
        print(f"Error: {response.get('message')}", file=sys.stderr)
        sys.exit(1)
    else:
        print("Cursor opened successfully")


def main():
    parser = argparse.ArgumentParser(
        description="VIB - Remote Development Bridge Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  Setup (run once):
    vib config user@192.168.1.100    Save remote host to config

  Local machine:
    vib daemon              Start daemon and SSH to configured host
    vib daemon user@host    Start daemon and SSH to specified host

  Remote machine (after 'vib daemon' connects):
    vib openpr              Open GitHub PR creation page for current branch
    vib curs                Open Cursor connected to current directory
    vib curs /path/to/dir   Open Cursor connected to specific directory
    vib curs --diff         Open Cursor with Source Control view focused
        """,
    )

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # config command
    config_parser = subparsers.add_parser("config", help="Configure remote host")
    config_parser.add_argument("host", nargs="?", help="Remote host (e.g., user@192.168.1.100)")
    config_parser.set_defaults(func=cmd_config)

    # daemon command
    daemon_parser = subparsers.add_parser("daemon", help="Start daemon and SSH to remote")
    daemon_parser.add_argument("host", nargs="?", help="Remote host (overrides config)")
    daemon_parser.set_defaults(func=cmd_daemon)

    # openpr command
    openpr_parser = subparsers.add_parser("openpr", help="Open GitHub PR creation page")
    openpr_parser.set_defaults(func=cmd_openpr)

    # curs command
    curs_parser = subparsers.add_parser("curs", help="Open Cursor with SSH remote")
    curs_parser.add_argument("path", nargs="?", help="Path to open (default: current directory)")
    curs_parser.add_argument("--diff", action="store_true", help="Open Source Control view for diffs")
    curs_parser.set_defaults(func=cmd_curs)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    args.func(args)


if __name__ == "__main__":
    main()
