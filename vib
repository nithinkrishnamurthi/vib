#!/usr/bin/env python3
"""
VIB - Remote Development Bridge Tool

A CLI tool that enables commands run on a remote SSH machine to trigger
actions on the local/client machine via SSH Unix socket forwarding.
"""

import argparse
import json
import os
import re
import signal
import socket
import subprocess
import sys
import threading
import time
from pathlib import Path


# Paths
VIB_DIR = Path.home() / ".vib"
LOCAL_SOCKET = VIB_DIR / "vib.sock"
REMOTE_SOCKET = Path(f"/tmp/vib-{os.environ.get('USER', 'unknown')}.sock")
CONFIG_FILE = VIB_DIR / "config"


def parse_ssh_config():
    """Parse ~/.ssh/config and return a mapping of HostName -> Host alias."""
    ssh_config = Path.home() / ".ssh" / "config"
    if not ssh_config.exists():
        return {}

    mapping = {}
    current_host = None

    try:
        for line in ssh_config.read_text().splitlines():
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            # Match "Host alias" (but not wildcard patterns)
            if line.lower().startswith("host ") and not line.lower().startswith("hostname"):
                alias = line.split(None, 1)[1].strip()
                if "*" not in alias and "?" not in alias:
                    current_host = alias
                else:
                    current_host = None
            # Match "HostName actual.hostname.com"
            elif line.lower().startswith("hostname") and current_host:
                hostname = line.split(None, 1)[1].strip() if len(line.split(None, 1)) > 1 else None
                if hostname:
                    mapping[hostname] = current_host
        return mapping
    except Exception:
        return {}


def get_config_value(key: str, default: str = None) -> str:
    """Get a config value from ~/.vib/config by key.

    Format:
        key = value

    Args:
        key: The config key to look up (case-insensitive)
        default: Default value if key not found

    Returns:
        The config value or default if not found
    """
    if not CONFIG_FILE.exists():
        return default

    try:
        for line in CONFIG_FILE.read_text().splitlines():
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            if line.lower().startswith(key.lower()):
                # "key = value" or "key=value"
                if "=" in line:
                    return line.split("=", 1)[1].strip()
        return default
    except Exception:
        return default


def get_config_host():
    """Get the SSH host alias from ~/.vib/config on the remote.

    Format:
        host = anton
    """
    return get_config_value("host")


def get_iosbuild_config() -> dict:
    """Get iOS build configuration from ~/.vib/config.

    Returns:
        dict with 'path' and 'command' keys
    """
    return {
        "path": get_config_value("iosbuild_path"),
        "command": get_config_value("iosbuild_command", "./scripts/local-ios-build.sh"),
    }


def resolve_hostname_to_ips(hostname: str) -> list:
    """Resolve a hostname to its IP addresses."""
    try:
        results = socket.getaddrinfo(hostname, None, socket.AF_UNSPEC, socket.SOCK_STREAM)
        return list(set(r[4][0] for r in results))
    except socket.gaierror:
        return []


def resolve_host_alias(host: str) -> str:
    """Resolve an IP/hostname to an SSH config Host alias.

    Parses ~/.ssh/config, resolves each HostName to IPs,
    and matches against the incoming host.
    """
    # Get mapping of HostName -> Host alias from SSH config
    ssh_mapping = parse_ssh_config()

    # Direct match on hostname
    if host in ssh_mapping:
        return ssh_mapping[host]

    # Resolve each HostName to IPs and check for match
    for hostname, alias in ssh_mapping.items():
        ips = resolve_hostname_to_ips(hostname)
        if host in ips:
            return alias

    return host


def get_git_branch():
    """Get the current git branch name."""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--abbrev-ref", "HEAD"],
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        return None


def get_git_remote_url():
    """Get the GitHub URL from git remote."""
    try:
        result = subprocess.run(
            ["git", "remote", "get-url", "origin"],
            capture_output=True,
            text=True,
            check=True,
        )
        url = result.stdout.strip()
        # Convert SSH URL to HTTPS if needed
        if url.startswith("git@github.com:"):
            url = url.replace("git@github.com:", "https://github.com/")
        if url.endswith(".git"):
            url = url[:-4]
        return url
    except subprocess.CalledProcessError:
        return None


def git_push_current_branch() -> tuple:
    """Push current branch to origin.

    Returns:
        (success: bool, message: str) tuple
    """
    branch = get_git_branch()
    if not branch:
        return (False, "Not in a git repository or cannot determine branch")

    # Check for uncommitted changes
    try:
        result = subprocess.run(
            ["git", "status", "--porcelain"],
            capture_output=True,
            text=True,
            check=True,
        )
        if result.stdout.strip():
            return (False, "Uncommitted changes detected. Please commit before running iosbuild.")
    except subprocess.CalledProcessError as e:
        return (False, f"Failed to check git status: {e}")

    # Push to origin
    try:
        result = subprocess.run(
            ["git", "push", "-u", "origin", branch],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            error_msg = result.stderr.strip() or result.stdout.strip()
            return (False, f"Failed to push: {error_msg}")
        return (True, f"Pushed to origin/{branch}")
    except subprocess.CalledProcessError as e:
        return (False, f"Failed to push: {e}")


def get_remote_host():
    """Get the remote host identifier for SSH connection."""
    # Try SSH_CONNECTION first (format: "client_ip client_port server_ip server_port")
    ssh_conn = os.environ.get("SSH_CONNECTION")
    if ssh_conn:
        parts = ssh_conn.split()
        if len(parts) >= 3:
            # Return the server IP that the client connected to
            return parts[2]

    # Fall back to hostname
    try:
        result = subprocess.run(
            ["hostname", "-f"],
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        return socket.gethostname()


class TunnelManager:
    """Manages SSH tunnel with automatic reconnection."""

    def __init__(self, host: str, local_socket: Path, stop_event: threading.Event):
        self.host = host
        self.local_socket = local_socket
        self.remote_socket = f"/tmp/vib-{os.environ.get('USER', 'unknown')}.sock"
        self.stop_event = stop_event
        self.process = None
        self.backoff = 1  # Start with 1 second
        self.max_backoff = 60  # Max 60 seconds

    def _build_ssh_command(self) -> list:
        """Build the SSH command for reverse forwarding."""
        return [
            "ssh",
            "-N",  # No remote command
            "-o", "ServerAliveInterval=30",
            "-o", "ServerAliveCountMax=3",
            "-o", "ExitOnForwardFailure=yes",
            "-o", "BatchMode=yes",  # Don't prompt for password
            "-o", "StreamLocalBindUnlink=yes",  # Remove stale socket before binding
            "-R", f"{self.remote_socket}:{self.local_socket}",
            self.host,
        ]

    def _start_ssh(self) -> bool:
        """Start the SSH subprocess. Returns True if started successfully."""
        cmd = self._build_ssh_command()
        try:
            self.process = subprocess.Popen(
                cmd,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.PIPE,
            )
            # Give SSH a moment to establish or fail
            time.sleep(1)

            if self.process.poll() is not None:
                # Process already exited
                stderr = self.process.stderr.read().decode().strip() if self.process.stderr else ""
                print(f"SSH tunnel failed to start: {stderr}")
                return False

            print(f"SSH tunnel established to {self.host}")
            self.backoff = 1  # Reset backoff on success
            return True
        except Exception as e:
            print(f"Failed to start SSH: {e}")
            return False

    def _wait_for_exit(self) -> int:
        """Wait for SSH process to exit. Returns exit code."""
        if self.process is None:
            return -1

        while not self.stop_event.is_set():
            try:
                exit_code = self.process.wait(timeout=1)
                stderr = self.process.stderr.read().decode().strip() if self.process.stderr else ""
                if stderr:
                    print(f"SSH tunnel closed: {stderr}")
                else:
                    print(f"SSH tunnel closed (exit code {exit_code})")
                return exit_code
            except subprocess.TimeoutExpired:
                continue

        return 0

    def run(self):
        """Main loop: start SSH, monitor, reconnect on failure."""
        print(f"Starting tunnel manager for {self.host}...")

        while not self.stop_event.is_set():
            if self._start_ssh():
                self._wait_for_exit()

            if self.stop_event.is_set():
                break

            print(f"Reconnecting in {self.backoff}s...")
            # Wait with stop_event check
            for _ in range(self.backoff):
                if self.stop_event.is_set():
                    return
                time.sleep(1)

            # Exponential backoff
            self.backoff = min(self.backoff * 2, self.max_backoff)

    def stop(self):
        """Stop the SSH tunnel."""
        if self.process and self.process.poll() is None:
            print("Terminating SSH tunnel...")
            self.process.terminate()
            try:
                self.process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                self.process.kill()


def send_to_daemon(message: dict, socket_path: Path = REMOTE_SOCKET) -> dict:
    """Send a message to the daemon and get response."""
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    try:
        sock.connect(str(socket_path))
        sock.sendall(json.dumps(message).encode() + b"\n")

        # Receive response
        response = b""
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            response += chunk
            if b"\n" in response:
                break

        if response:
            return json.loads(response.decode().strip())
        return {"status": "ok"}
    except FileNotFoundError:
        return {"status": "error", "message": f"Socket not found: {socket_path}. Is the daemon running?"}
    except ConnectionRefusedError:
        return {"status": "error", "message": "Connection refused. Is the daemon running?"}
    except Exception as e:
        return {"status": "error", "message": str(e)}
    finally:
        sock.close()


def handle_daemon_request(data: dict) -> dict:
    """Handle an incoming request on the daemon side."""
    action = data.get("action")

    if action == "openpr":
        return handle_openpr_daemon(data)
    elif action == "curs":
        return handle_curs_daemon(data)
    elif action == "iosbuild":
        return handle_iosbuild_daemon(data)
    else:
        return {"status": "error", "message": f"Unknown action: {action}"}


def handle_openpr_daemon(data: dict) -> dict:
    """Handle openpr request - open Chrome with PR URL."""
    branch = data.get("branch")
    repo_url = data.get("repo_url")

    if not branch or not repo_url:
        return {"status": "error", "message": "Missing branch or repo_url"}

    # Extract owner/repo from URL
    # URL format: https://github.com/owner/repo
    parts = repo_url.rstrip("/").split("/")
    if len(parts) < 2:
        return {"status": "error", "message": f"Invalid repo URL: {repo_url}"}

    owner = parts[-2]
    repo = parts[-1]

    pr_url = f"https://github.com/{owner}/{repo}/compare/{branch}?expand=1"

    try:
        # Try different browser commands (macOS uses 'open', Linux uses xdg-open or specific browsers)
        for browser in ["open", "xdg-open", "google-chrome", "google-chrome-stable", "chromium", "chromium-browser"]:
            try:
                subprocess.Popen(
                    [browser, pr_url],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                )
                print(f"Opened PR URL: {pr_url}")
                return {"status": "ok", "url": pr_url}
            except FileNotFoundError:
                continue

        return {"status": "error", "message": "No browser found"}
    except Exception as e:
        return {"status": "error", "message": str(e)}


def handle_curs_daemon(data: dict) -> dict:
    """Handle curs request - open Cursor with SSH remote."""
    host = data.get("host")
    user = data.get("user")
    path = data.get("path")
    diff = data.get("diff", False)

    if not host or not path:
        return {"status": "error", "message": "Missing host or path"}

    # Resolve host to SSH config alias (e.g., "192.168.0.35" -> "anton")
    host_alias = resolve_host_alias(host)
    if host_alias != host:
        print(f"Resolved {host} -> {host_alias}")

    # Build remote identifier using the alias (don't include user if using alias)
    if host_alias != host:
        # Using SSH config alias - it already has user configured
        remote_id = host_alias
    elif user:
        remote_id = f"{user}@{host}"
    else:
        remote_id = host

    # Find cursor binary - check PATH first, then common macOS locations
    cursor_paths = [
        "cursor",  # Check PATH first
        "/Applications/Cursor.app/Contents/Resources/app/bin/cursor",
        "/usr/local/bin/cursor",
        os.path.expanduser("~/Applications/Cursor.app/Contents/Resources/app/bin/cursor"),
    ]

    cursor_bin = None
    for cp in cursor_paths:
        if cp == "cursor":
            # Check if cursor is in PATH
            import shutil
            if shutil.which("cursor"):
                cursor_bin = "cursor"
                break
        elif os.path.exists(cp):
            cursor_bin = cp
            break

    if not cursor_bin:
        return {"status": "error", "message": "Cursor not found. Install Cursor or check installation path."}

    try:
        # Open Cursor with SSH remote
        subprocess.Popen(
            [cursor_bin, "--remote", f"ssh-remote+{remote_id}", path],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        print(f"Opening Cursor: ssh-remote+{remote_id} {path}")

        if diff:
            # Give Cursor time to start, then open Source Control view
            import time
            time.sleep(2)
            subprocess.Popen(
                [cursor_bin, "--goto", "scm"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            print("Opening Source Control view")

        return {"status": "ok", "remote": remote_id, "path": path, "diff": diff}
    except FileNotFoundError:
        return {"status": "error", "message": "Cursor not found"}
    except Exception as e:
        return {"status": "error", "message": str(e)}


def open_terminal_with_command(path: str, command: str) -> tuple:
    """Open a new terminal window and run a command.

    Args:
        path: Directory to cd into before running command
        command: Command to execute

    Returns:
        (success: bool, message: str) tuple
    """
    import platform
    import shutil

    system = platform.system()

    if system == "Darwin":
        # macOS: Use osascript with AppleScript to open Terminal.app
        apple_script = f'''
tell application "Terminal"
    activate
    do script "cd \\"{path}\\" && {command}"
end tell
'''
        try:
            subprocess.Popen(
                ["osascript", "-e", apple_script],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            return (True, "Opened Terminal.app")
        except Exception as e:
            return (False, f"Failed to open Terminal: {e}")

    elif system == "Linux":
        # Linux: Try terminal emulators in order of preference
        terminals = [
            ("gnome-terminal", ["gnome-terminal", "--", "bash", "-c", f'cd "{path}" && {command}; exec bash']),
            ("konsole", ["konsole", "-e", "bash", "-c", f'cd "{path}" && {command}; exec bash']),
            ("xfce4-terminal", ["xfce4-terminal", "-e", f'bash -c "cd \\"{path}\\" && {command}; exec bash"']),
            ("xterm", ["xterm", "-e", f'bash -c "cd \\"{path}\\" && {command}; exec bash"']),
        ]

        for name, cmd in terminals:
            if shutil.which(name):
                try:
                    subprocess.Popen(
                        cmd,
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL,
                    )
                    return (True, f"Opened {name}")
                except Exception as e:
                    continue

        return (False, "No supported terminal emulator found (tried: gnome-terminal, konsole, xfce4-terminal, xterm)")

    else:
        return (False, f"Unsupported platform: {system}")


def sanitize_branch_for_path(branch: str) -> str:
    """Sanitize branch name for use in directory path."""
    # Replace problematic characters with dashes
    sanitized = re.sub(r'[/\\:\s]+', '-', branch)
    # Collapse multiple dashes to single dash
    sanitized = re.sub(r'-+', '-', sanitized)
    # Strip leading/trailing dashes
    return sanitized.strip('-')


def get_default_branch(repo_path: str) -> str:
    """Get the default branch name from the remote."""
    try:
        result = subprocess.run(
            ["git", "remote", "show", "origin"],
            cwd=repo_path,
            capture_output=True,
            text=True,
        )
        if result.returncode == 0:
            for line in result.stdout.splitlines():
                if "HEAD branch:" in line:
                    return line.split(":")[-1].strip()
    except Exception:
        pass
    return "main"  # Fallback


def get_worktree_path(base_path: str, branch: str) -> str:
    """Calculate worktree path for a branch."""
    base_dir = os.path.dirname(base_path)
    base_name = os.path.basename(base_path)
    sanitized = sanitize_branch_for_path(branch)
    return os.path.join(base_dir, f"{base_name}--{sanitized}")


def ensure_worktree(repo_path: str, branch: str, worktree_path: str) -> tuple:
    """Ensure worktree exists for the branch. Returns (success, message)."""
    if os.path.isdir(worktree_path):
        return (True, f"Worktree already exists at {worktree_path}")

    # Create the worktree
    result = subprocess.run(
        ["git", "worktree", "add", worktree_path, branch],
        cwd=repo_path,
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        # Try creating with tracking branch
        result = subprocess.run(
            ["git", "worktree", "add", "-b", branch, worktree_path, f"origin/{branch}"],
            cwd=repo_path,
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            return (False, f"git worktree add failed: {result.stderr.strip()}")

    return (True, f"Created worktree at {worktree_path}")


def update_worktree(worktree_path: str, branch: str) -> tuple:
    """Fetch and reset worktree to origin/branch. Returns (success, message)."""
    # Fetch in the worktree
    result = subprocess.run(
        ["git", "fetch", "origin"],
        cwd=worktree_path,
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        return (False, f"git fetch failed: {result.stderr.strip()}")

    # Reset to origin/branch
    result = subprocess.run(
        ["git", "reset", "--hard", f"origin/{branch}"],
        cwd=worktree_path,
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        return (False, f"git reset failed: {result.stderr.strip()}")

    return (True, "Updated to latest")


def handle_iosbuild_daemon(data: dict) -> dict:
    """Handle iosbuild request - pull branch and run build in new terminal."""
    branch = data.get("branch")
    repo_url = data.get("repo_url")
    build_args = data.get("build_args", [])

    if not branch:
        return {"status": "error", "message": "Missing branch"}

    # Get config
    config = get_iosbuild_config()
    base_path = config["path"]
    command = config["command"]

    # Append any extra build arguments
    if build_args:
        command = f"{command} {' '.join(build_args)}"

    if not base_path:
        return {"status": "error", "message": "iosbuild_path not configured in ~/.vib/config"}

    # Validate path exists and is a git repo
    if not os.path.isdir(base_path):
        return {"status": "error", "message": f"iosbuild_path does not exist: {base_path}"}

    git_dir = os.path.join(base_path, ".git")
    if not os.path.isdir(git_dir):
        return {"status": "error", "message": f"iosbuild_path is not a git repository: {base_path}"}

    try:
        # Fetch from origin in main repo first
        print(f"Fetching from origin in {base_path}...")
        result = subprocess.run(
            ["git", "fetch", "origin"],
            cwd=base_path,
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            return {"status": "error", "message": f"git fetch failed: {result.stderr.strip()}"}

        # Determine if we use main repo or a worktree
        default_branch = get_default_branch(base_path)
        using_worktree = branch != default_branch

        if using_worktree:
            # Use worktree for non-default branches
            work_path = get_worktree_path(base_path, branch)
            print(f"Using worktree at {work_path}...")

            # Ensure worktree exists
            success, message = ensure_worktree(base_path, branch, work_path)
            if not success:
                return {"status": "error", "message": message}
            print(message)

            # Update worktree to latest
            success, message = update_worktree(work_path, branch)
            if not success:
                return {"status": "error", "message": message}
            print(f"Reset to origin/{branch}")
        else:
            # Use main repo for default branch
            work_path = base_path
            print(f"Using main repo for default branch {branch}...")

            # Checkout branch
            print(f"Checking out branch {branch}...")
            result = subprocess.run(
                ["git", "checkout", branch],
                cwd=work_path,
                capture_output=True,
                text=True,
            )
            if result.returncode != 0:
                # Try creating tracking branch
                result = subprocess.run(
                    ["git", "checkout", "-b", branch, f"origin/{branch}"],
                    cwd=work_path,
                    capture_output=True,
                    text=True,
                )
                if result.returncode != 0:
                    return {"status": "error", "message": f"git checkout failed: {result.stderr.strip()}"}

            # Reset to match remote
            print(f"Resetting to origin/{branch}...")
            result = subprocess.run(
                ["git", "reset", "--hard", f"origin/{branch}"],
                cwd=work_path,
                capture_output=True,
                text=True,
            )
            if result.returncode != 0:
                return {"status": "error", "message": f"git reset failed: {result.stderr.strip()}"}

        # Open terminal with build command
        print(f"Opening terminal to run: {command}")
        success, message = open_terminal_with_command(work_path, command)
        if not success:
            return {"status": "error", "message": message}

        return {
            "status": "ok",
            "branch": branch,
            "path": work_path,
            "command": command,
            "worktree": using_worktree,
        }

    except Exception as e:
        return {"status": "error", "message": str(e)}


def run_socket_listener(sock, stop_event):
    """Run the socket listener in a thread."""
    sock.settimeout(1.0)  # Allow periodic checking of stop_event
    while not stop_event.is_set():
        try:
            conn, _ = sock.accept()
            try:
                data = b""
                while True:
                    chunk = conn.recv(4096)
                    if not chunk:
                        break
                    data += chunk
                    if b"\n" in data:
                        break

                if data:
                    try:
                        message = json.loads(data.decode().strip())
                        print(f"Received: {message}")
                        response = handle_daemon_request(message)
                    except json.JSONDecodeError as e:
                        response = {"status": "error", "message": f"Invalid JSON: {e}"}

                    conn.sendall(json.dumps(response).encode() + b"\n")
            finally:
                conn.close()
        except socket.timeout:
            continue
        except Exception as e:
            if not stop_event.is_set():
                print(f"Socket error: {e}")


def run_daemon(tunnel_host: str = None):
    """Run the daemon that listens for commands.

    Args:
        tunnel_host: If provided, establish SSH tunnel to this host with reverse forwarding
    """
    # Ensure socket directory exists
    LOCAL_SOCKET.parent.mkdir(parents=True, exist_ok=True)

    # Remove existing socket
    if LOCAL_SOCKET.exists():
        LOCAL_SOCKET.unlink()

    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.bind(str(LOCAL_SOCKET))
    sock.listen(5)

    # Set socket permissions
    os.chmod(LOCAL_SOCKET, 0o600)

    print(f"VIB daemon listening on {LOCAL_SOCKET}")

    stop_event = threading.Event()
    tunnel_manager = None

    # Start tunnel if host specified
    if tunnel_host:
        print(f"Establishing SSH tunnel to {tunnel_host}...")
        tunnel_manager = TunnelManager(tunnel_host, LOCAL_SOCKET, stop_event)
        tunnel_thread = threading.Thread(
            target=tunnel_manager.run,
            daemon=True,
        )
        tunnel_thread.start()
    else:
        print(f"Add to ~/.ssh/config: RemoteForward /tmp/vib-$USER.sock {LOCAL_SOCKET}")

    print("Press Ctrl+C to stop...")

    # Start socket listener in a thread
    listener_thread = threading.Thread(
        target=run_socket_listener,
        args=(sock, stop_event),
        daemon=True,
    )
    listener_thread.start()

    # Set up signal handlers for graceful shutdown
    def handle_signal(signum, frame):
        print(f"\nReceived signal {signum}, shutting down...")
        stop_event.set()

    signal.signal(signal.SIGTERM, handle_signal)
    signal.signal(signal.SIGINT, handle_signal)

    try:
        while not stop_event.is_set():
            signal.pause()
    except KeyboardInterrupt:
        pass
    finally:
        print("Shutting down...")
        stop_event.set()
        if tunnel_manager:
            tunnel_manager.stop()
        sock.close()
        if LOCAL_SOCKET.exists():
            LOCAL_SOCKET.unlink()


def cmd_daemon(args):
    """Handle 'vib daemon' command."""
    tunnel_host = None

    if args.tunnel is not None:
        if args.tunnel:
            # Explicit host provided: --tunnel gpu
            tunnel_host = args.tunnel
        else:
            # Just --tunnel with no argument, read from config
            tunnel_host = get_config_host()
            if not tunnel_host:
                print("Error: No host specified and no host in ~/.vib/config", file=sys.stderr)
                print("Usage: vib daemon --tunnel HOST  or  set 'host = yourhost' in ~/.vib/config", file=sys.stderr)
                sys.exit(1)

    run_daemon(tunnel_host=tunnel_host)


def cmd_install(args):
    """Handle 'vib install' command - set up systemd user service."""
    import shutil

    # Check for systemd
    if not shutil.which("systemctl"):
        print("Error: systemctl not found. Is systemd installed?", file=sys.stderr)
        sys.exit(1)

    # Get the host for the tunnel
    host = args.host if args.host else get_config_host()
    if not host:
        print("Error: No host specified and no host in ~/.vib/config", file=sys.stderr)
        print("Usage: vib install HOST  or  set 'host = yourhost' in ~/.vib/config first", file=sys.stderr)
        sys.exit(1)

    # Get path to this script
    vib_path = os.path.abspath(__file__)

    # Create systemd user directory
    systemd_dir = Path.home() / ".config" / "systemd" / "user"
    systemd_dir.mkdir(parents=True, exist_ok=True)

    service_file = systemd_dir / "vib.service"

    # Create service file content
    service_content = f"""[Unit]
Description=VIB Remote Development Bridge
After=network.target

[Service]
Type=simple
ExecStart={vib_path} daemon --tunnel {host}
Restart=on-failure
RestartSec=5

[Install]
WantedBy=default.target
"""

    # Write service file
    service_file.write_text(service_content)
    print(f"Created {service_file}")

    # Run systemctl commands
    commands = [
        (["systemctl", "--user", "daemon-reload"], "Reloading systemd..."),
        (["systemctl", "--user", "enable", "vib"], "Enabling vib service..."),
        (["systemctl", "--user", "restart", "vib"], "Starting vib service..."),
    ]

    for cmd, msg in commands:
        print(msg)
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode != 0:
            print(f"Error: {result.stderr.strip()}", file=sys.stderr)
            sys.exit(1)

    # Print status
    print("\nVIB service installed and started!")
    print(f"Tunnel target: {host}")
    print("\nUseful commands:")
    print("  systemctl --user status vib    # Check status")
    print("  journalctl --user -u vib -f    # View logs")
    print("  systemctl --user restart vib   # Restart service")
    print("  systemctl --user stop vib      # Stop service")

    # Show current status
    print("\nCurrent status:")
    subprocess.run(["systemctl", "--user", "status", "vib", "--no-pager"])


def cmd_openpr(args):
    """Handle 'vib openpr' command."""
    branch = get_git_branch()
    if not branch:
        print("Error: Not in a git repository or cannot determine branch", file=sys.stderr)
        sys.exit(1)

    repo_url = get_git_remote_url()
    if not repo_url:
        print("Error: Cannot determine git remote URL", file=sys.stderr)
        sys.exit(1)

    if "github.com" not in repo_url:
        print(f"Error: Only GitHub repositories are supported. Got: {repo_url}", file=sys.stderr)
        sys.exit(1)

    message = {
        "action": "openpr",
        "branch": branch,
        "repo_url": repo_url,
    }

    print(f"Opening PR for branch '{branch}' in {repo_url}")
    response = send_to_daemon(message)

    if response.get("status") == "error":
        print(f"Error: {response.get('message')}", file=sys.stderr)
        sys.exit(1)
    else:
        print(f"PR URL opened: {response.get('url', 'unknown')}")


def cmd_curs(args):
    """Handle 'vib curs' command."""
    # Get path (default to cwd)
    path = args.path if args.path else os.getcwd()
    path = os.path.abspath(path)

    # Get remote host info (priority: ~/.vib/config > VIB_HOST env > auto-detect)
    host = get_config_host() or os.environ.get("VIB_HOST") or get_remote_host()
    user = os.environ.get("USER")

    message = {
        "action": "curs",
        "host": host,
        "user": user,
        "path": path,
        "diff": args.diff,
    }

    print(f"Opening Cursor for {user}@{host}:{path}" + (" (diff mode)" if args.diff else ""))
    response = send_to_daemon(message)

    if response.get("status") == "error":
        print(f"Error: {response.get('message')}", file=sys.stderr)
        sys.exit(1)
    else:
        print("Cursor opened successfully")


def cmd_iosbuild(args):
    """Handle 'vib iosbuild' command."""
    branch = get_git_branch()
    if not branch:
        print("Error: Not in a git repository or cannot determine branch", file=sys.stderr)
        sys.exit(1)

    repo_url = get_git_remote_url()

    # Push to origin unless --no-push
    if not args.no_push:
        print(f"Pushing to origin/{branch}...")
        success, message = git_push_current_branch()
        if not success:
            print(f"Error: {message}", file=sys.stderr)
            sys.exit(1)
        print(message)

    # Send message to daemon
    message = {
        "action": "iosbuild",
        "branch": branch,
        "repo_url": repo_url,
        "build_args": args.build_args,
    }

    print("Triggering iOS build...")
    response = send_to_daemon(message)

    if response.get("status") == "error":
        print(f"Error: {response.get('message')}", file=sys.stderr)
        sys.exit(1)
    else:
        worktree_suffix = " (Using worktree)" if response.get("worktree") else ""
        print(f"iOS build triggered successfully!{worktree_suffix}")
        print(f"  Branch: {response.get('branch')}")
        print(f"  Path: {response.get('path')}")
        print(f"  Command: {response.get('command')}")


def main():
    parser = argparse.ArgumentParser(
        description="VIB - Remote Development Bridge Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  Local machine setup (one-time):
    vib install anton       Install as systemd service with tunnel to 'anton'
    vib install             Use host from ~/.vib/config

  Local machine (manual):
    vib daemon --tunnel anton   Start daemon with SSH tunnel to 'anton'
    vib daemon --tunnel         Use host from ~/.vib/config
    vib daemon                  Start daemon only (manual SSH forwarding)

  Remote machine (via SSH):
    vib openpr              Open GitHub PR creation page for current branch
    vib curs                Open Cursor connected to current directory
    vib curs /path/to/dir   Open Cursor connected to specific directory
    vib curs --diff         Open Cursor with Source Control view focused
    vib iosbuild            Push changes and trigger iOS build on client
    vib iosbuild --no-push  Trigger build without pushing (already pushed)
    vib iosbuild --clean    Pass --clean flag to the build script

  Config file (~/.vib/config):
    host = anton            Default SSH host for tunnel
    iosbuild_path = /Users/nithin/Projects/MyiOSApp
                            Path to iOS repo on client (required for iosbuild)
    iosbuild_command = ./scripts/local-ios-build.sh
                            Build command to run (default: ./scripts/local-ios-build.sh)

  Service management:
    systemctl --user status vib     Check service status
    journalctl --user -u vib -f     View logs
    systemctl --user restart vib    Restart service
        """,
    )

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # daemon command
    daemon_parser = subparsers.add_parser("daemon", help="Start the local daemon")
    daemon_parser.add_argument(
        "--tunnel", nargs="?", const="", default=None, metavar="HOST",
        help="Establish SSH tunnel to HOST (uses ~/.vib/config if HOST not specified)"
    )
    daemon_parser.set_defaults(func=cmd_daemon)

    # install command
    install_parser = subparsers.add_parser("install", help="Install as systemd user service")
    install_parser.add_argument(
        "host", nargs="?", default=None,
        help="SSH host to tunnel to (uses ~/.vib/config if not specified)"
    )
    install_parser.set_defaults(func=cmd_install)

    # openpr command
    openpr_parser = subparsers.add_parser("openpr", help="Open GitHub PR creation page")
    openpr_parser.set_defaults(func=cmd_openpr)

    # curs command
    curs_parser = subparsers.add_parser("curs", help="Open Cursor with SSH remote")
    curs_parser.add_argument("path", nargs="?", help="Path to open (default: current directory)")
    curs_parser.add_argument("--diff", action="store_true", help="Open Source Control view for diffs")
    curs_parser.set_defaults(func=cmd_curs)

    # iosbuild command
    iosbuild_parser = subparsers.add_parser("iosbuild", help="Trigger iOS build on client machine")
    iosbuild_parser.add_argument(
        "--no-push", action="store_true",
        help="Don't push changes before triggering build"
    )
    iosbuild_parser.set_defaults(func=cmd_iosbuild)

    args, remaining = parser.parse_known_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    # Pass remaining unknown args as build_args for iosbuild
    if args.command == "iosbuild":
        args.build_args = remaining
    elif remaining:
        parser.error(f"unrecognized arguments: {' '.join(remaining)}")

    args.func(args)


if __name__ == "__main__":
    main()
