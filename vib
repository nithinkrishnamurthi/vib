#!/usr/bin/env python3
"""
VIB - Remote Development Bridge Tool

A CLI tool that enables commands run on a remote SSH machine to trigger
actions on the local/client machine via SSH Unix socket forwarding.
"""

import argparse
import json
import os
import signal
import socket
import subprocess
import sys
import threading
from pathlib import Path


# Paths
VIB_DIR = Path.home() / ".vib"
LOCAL_SOCKET = VIB_DIR / "vib.sock"
REMOTE_SOCKET = Path(f"/tmp/vib-{os.environ.get('USER', 'unknown')}.sock")
CONFIG_FILE = VIB_DIR / "config"


def parse_ssh_config():
    """Parse ~/.ssh/config and return a mapping of HostName -> Host alias."""
    ssh_config = Path.home() / ".ssh" / "config"
    if not ssh_config.exists():
        return {}

    mapping = {}
    current_host = None

    try:
        for line in ssh_config.read_text().splitlines():
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            # Match "Host alias" (but not wildcard patterns)
            if line.lower().startswith("host ") and not line.lower().startswith("hostname"):
                alias = line.split(None, 1)[1].strip()
                if "*" not in alias and "?" not in alias:
                    current_host = alias
                else:
                    current_host = None
            # Match "HostName actual.hostname.com"
            elif line.lower().startswith("hostname") and current_host:
                hostname = line.split(None, 1)[1].strip() if len(line.split(None, 1)) > 1 else None
                if hostname:
                    mapping[hostname] = current_host
        return mapping
    except Exception:
        return {}


def resolve_hostname_to_ips(hostname: str) -> list:
    """Resolve a hostname to its IP addresses."""
    try:
        results = socket.getaddrinfo(hostname, None, socket.AF_UNSPEC, socket.SOCK_STREAM)
        return list(set(r[4][0] for r in results))
    except socket.gaierror:
        return []


def resolve_host_alias(host: str) -> str:
    """Resolve an IP/hostname to an SSH config Host alias.

    Parses ~/.ssh/config, resolves each HostName to IPs,
    and matches against the incoming host.
    """
    # Get mapping of HostName -> Host alias from SSH config
    ssh_mapping = parse_ssh_config()

    # Direct match on hostname
    if host in ssh_mapping:
        return ssh_mapping[host]

    # Resolve each HostName to IPs and check for match
    for hostname, alias in ssh_mapping.items():
        ips = resolve_hostname_to_ips(hostname)
        if host in ips:
            return alias

    return host


def get_git_branch():
    """Get the current git branch name."""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--abbrev-ref", "HEAD"],
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        return None


def get_git_remote_url():
    """Get the GitHub URL from git remote."""
    try:
        result = subprocess.run(
            ["git", "remote", "get-url", "origin"],
            capture_output=True,
            text=True,
            check=True,
        )
        url = result.stdout.strip()
        # Convert SSH URL to HTTPS if needed
        if url.startswith("git@github.com:"):
            url = url.replace("git@github.com:", "https://github.com/")
        if url.endswith(".git"):
            url = url[:-4]
        return url
    except subprocess.CalledProcessError:
        return None


def get_remote_host():
    """Get the remote host identifier for SSH connection."""
    # Try SSH_CONNECTION first (format: "client_ip client_port server_ip server_port")
    ssh_conn = os.environ.get("SSH_CONNECTION")
    if ssh_conn:
        parts = ssh_conn.split()
        if len(parts) >= 3:
            # Return the server IP that the client connected to
            return parts[2]

    # Fall back to hostname
    try:
        result = subprocess.run(
            ["hostname", "-f"],
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        return socket.gethostname()


def send_to_daemon(message: dict, socket_path: Path = REMOTE_SOCKET) -> dict:
    """Send a message to the daemon and get response."""
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    try:
        sock.connect(str(socket_path))
        sock.sendall(json.dumps(message).encode() + b"\n")

        # Receive response
        response = b""
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            response += chunk
            if b"\n" in response:
                break

        if response:
            return json.loads(response.decode().strip())
        return {"status": "ok"}
    except FileNotFoundError:
        return {"status": "error", "message": f"Socket not found: {socket_path}. Is the daemon running?"}
    except ConnectionRefusedError:
        return {"status": "error", "message": "Connection refused. Is the daemon running?"}
    except Exception as e:
        return {"status": "error", "message": str(e)}
    finally:
        sock.close()


def handle_daemon_request(data: dict) -> dict:
    """Handle an incoming request on the daemon side."""
    action = data.get("action")

    if action == "openpr":
        return handle_openpr_daemon(data)
    elif action == "curs":
        return handle_curs_daemon(data)
    else:
        return {"status": "error", "message": f"Unknown action: {action}"}


def handle_openpr_daemon(data: dict) -> dict:
    """Handle openpr request - open Chrome with PR URL."""
    branch = data.get("branch")
    repo_url = data.get("repo_url")

    if not branch or not repo_url:
        return {"status": "error", "message": "Missing branch or repo_url"}

    # Extract owner/repo from URL
    # URL format: https://github.com/owner/repo
    parts = repo_url.rstrip("/").split("/")
    if len(parts) < 2:
        return {"status": "error", "message": f"Invalid repo URL: {repo_url}"}

    owner = parts[-2]
    repo = parts[-1]

    pr_url = f"https://github.com/{owner}/{repo}/compare/{branch}?expand=1"

    try:
        # Try different browser commands (macOS uses 'open', Linux uses xdg-open or specific browsers)
        for browser in ["open", "xdg-open", "google-chrome", "google-chrome-stable", "chromium", "chromium-browser"]:
            try:
                subprocess.Popen(
                    [browser, pr_url],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                )
                print(f"Opened PR URL: {pr_url}")
                return {"status": "ok", "url": pr_url}
            except FileNotFoundError:
                continue

        return {"status": "error", "message": "No browser found"}
    except Exception as e:
        return {"status": "error", "message": str(e)}


def handle_curs_daemon(data: dict) -> dict:
    """Handle curs request - open Cursor with SSH remote."""
    host = data.get("host")
    user = data.get("user")
    path = data.get("path")
    diff = data.get("diff", False)

    if not host or not path:
        return {"status": "error", "message": "Missing host or path"}

    # Resolve host to SSH config alias (e.g., "192.168.0.35" -> "anton")
    host_alias = resolve_host_alias(host)
    if host_alias != host:
        print(f"Resolved {host} -> {host_alias}")

    # Build remote identifier using the alias (don't include user if using alias)
    if host_alias != host:
        # Using SSH config alias - it already has user configured
        remote_id = host_alias
    elif user:
        remote_id = f"{user}@{host}"
    else:
        remote_id = host

    # Find cursor binary - check PATH first, then common macOS locations
    cursor_paths = [
        "cursor",  # Check PATH first
        "/Applications/Cursor.app/Contents/Resources/app/bin/cursor",
        "/usr/local/bin/cursor",
        os.path.expanduser("~/Applications/Cursor.app/Contents/Resources/app/bin/cursor"),
    ]

    cursor_bin = None
    for cp in cursor_paths:
        if cp == "cursor":
            # Check if cursor is in PATH
            import shutil
            if shutil.which("cursor"):
                cursor_bin = "cursor"
                break
        elif os.path.exists(cp):
            cursor_bin = cp
            break

    if not cursor_bin:
        return {"status": "error", "message": "Cursor not found. Install Cursor or check installation path."}

    try:
        # Open Cursor with SSH remote
        subprocess.Popen(
            [cursor_bin, "--remote", f"ssh-remote+{remote_id}", path],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        print(f"Opening Cursor: ssh-remote+{remote_id} {path}")

        if diff:
            # Give Cursor time to start, then open Source Control view
            import time
            time.sleep(2)
            subprocess.Popen(
                [cursor_bin, "--goto", "scm"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            print("Opening Source Control view")

        return {"status": "ok", "remote": remote_id, "path": path, "diff": diff}
    except FileNotFoundError:
        return {"status": "error", "message": "Cursor not found"}
    except Exception as e:
        return {"status": "error", "message": str(e)}


def run_socket_listener(sock, stop_event):
    """Run the socket listener in a thread."""
    sock.settimeout(1.0)  # Allow periodic checking of stop_event
    while not stop_event.is_set():
        try:
            conn, _ = sock.accept()
            try:
                data = b""
                while True:
                    chunk = conn.recv(4096)
                    if not chunk:
                        break
                    data += chunk
                    if b"\n" in data:
                        break

                if data:
                    try:
                        message = json.loads(data.decode().strip())
                        print(f"Received: {message}")
                        response = handle_daemon_request(message)
                    except json.JSONDecodeError as e:
                        response = {"status": "error", "message": f"Invalid JSON: {e}"}

                    conn.sendall(json.dumps(response).encode() + b"\n")
            finally:
                conn.close()
        except socket.timeout:
            continue
        except Exception as e:
            if not stop_event.is_set():
                print(f"Socket error: {e}")


def run_daemon():
    """Run the daemon that listens for commands."""
    # Ensure socket directory exists
    LOCAL_SOCKET.parent.mkdir(parents=True, exist_ok=True)

    # Remove existing socket
    if LOCAL_SOCKET.exists():
        LOCAL_SOCKET.unlink()

    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.bind(str(LOCAL_SOCKET))
    sock.listen(5)

    # Set socket permissions
    os.chmod(LOCAL_SOCKET, 0o600)

    print(f"VIB daemon listening on {LOCAL_SOCKET}")
    print(f"Add to ~/.ssh/config: RemoteForward /tmp/vib-$USER.sock {LOCAL_SOCKET}")
    print("Press Ctrl+C to stop...")

    stop_event = threading.Event()

    # Start socket listener in a thread
    listener_thread = threading.Thread(
        target=run_socket_listener,
        args=(sock, stop_event),
        daemon=True,
    )
    listener_thread.start()

    try:
        while True:
            signal.pause()
    except KeyboardInterrupt:
        print("\nShutting down...")
    finally:
        stop_event.set()
        sock.close()
        if LOCAL_SOCKET.exists():
            LOCAL_SOCKET.unlink()


def cmd_daemon(args):
    """Handle 'vib daemon' command."""
    run_daemon()


def cmd_openpr(args):
    """Handle 'vib openpr' command."""
    branch = get_git_branch()
    if not branch:
        print("Error: Not in a git repository or cannot determine branch", file=sys.stderr)
        sys.exit(1)

    repo_url = get_git_remote_url()
    if not repo_url:
        print("Error: Cannot determine git remote URL", file=sys.stderr)
        sys.exit(1)

    if "github.com" not in repo_url:
        print(f"Error: Only GitHub repositories are supported. Got: {repo_url}", file=sys.stderr)
        sys.exit(1)

    message = {
        "action": "openpr",
        "branch": branch,
        "repo_url": repo_url,
    }

    print(f"Opening PR for branch '{branch}' in {repo_url}")
    response = send_to_daemon(message)

    if response.get("status") == "error":
        print(f"Error: {response.get('message')}", file=sys.stderr)
        sys.exit(1)
    else:
        print(f"PR URL opened: {response.get('url', 'unknown')}")


def cmd_curs(args):
    """Handle 'vib curs' command."""
    # Get path (default to cwd)
    path = args.path if args.path else os.getcwd()
    path = os.path.abspath(path)

    # Get remote host info (daemon will resolve to SSH config alias)
    host = os.environ.get("VIB_HOST") or get_remote_host()
    user = os.environ.get("USER")

    message = {
        "action": "curs",
        "host": host,
        "user": user,
        "path": path,
        "diff": args.diff,
    }

    print(f"Opening Cursor for {user}@{host}:{path}" + (" (diff mode)" if args.diff else ""))
    response = send_to_daemon(message)

    if response.get("status") == "error":
        print(f"Error: {response.get('message')}", file=sys.stderr)
        sys.exit(1)
    else:
        print("Cursor opened successfully")


def main():
    parser = argparse.ArgumentParser(
        description="VIB - Remote Development Bridge Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  Local machine:
    vib daemon              Start daemon (add RemoteForward to SSH config)

  Remote machine (via SSH with socket forwarding):
    vib openpr              Open GitHub PR creation page for current branch
    vib curs                Open Cursor connected to current directory
    vib curs /path/to/dir   Open Cursor connected to specific directory
    vib curs --diff         Open Cursor with Source Control view focused

  SSH config (~/.ssh/config):
    Host myserver
      RemoteForward /tmp/vib-myuser.sock /home/myuser/.vib/vib.sock
        """,
    )

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # daemon command
    daemon_parser = subparsers.add_parser("daemon", help="Start the local daemon")
    daemon_parser.set_defaults(func=cmd_daemon)

    # openpr command
    openpr_parser = subparsers.add_parser("openpr", help="Open GitHub PR creation page")
    openpr_parser.set_defaults(func=cmd_openpr)

    # curs command
    curs_parser = subparsers.add_parser("curs", help="Open Cursor with SSH remote")
    curs_parser.add_argument("path", nargs="?", help="Path to open (default: current directory)")
    curs_parser.add_argument("--diff", action="store_true", help="Open Source Control view for diffs")
    curs_parser.set_defaults(func=cmd_curs)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    args.func(args)


if __name__ == "__main__":
    main()
